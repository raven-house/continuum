
/* Autogenerated file, do not edit! */

/* eslint-disable */
import { AztecAddress, CompleteAddress } from '@aztec/aztec.js/addresses';
import { type AbiType, type AztecAddressLike, type ContractArtifact, EventSelector, decodeFromAbi, type EthAddressLike, type FieldLike, type FunctionSelectorLike, loadContractArtifact, loadContractArtifactForPublic, type NoirCompiledContract, type U128Like, type WrappedFieldLike } from '@aztec/aztec.js/abi';
import { Contract, ContractBase, ContractFunctionInteraction, type ContractMethod, type ContractStorageLayout, DeployMethod } from '@aztec/aztec.js/contracts';
import { EthAddress } from '@aztec/aztec.js/addresses';
import { Fr, Point } from '@aztec/aztec.js/fields';
import { type PublicKey, PublicKeys } from '@aztec/aztec.js/keys';
import type { Wallet } from '@aztec/aztec.js/wallet';
import NFTContractArtifactJson from './nft_contract-NFT.json' with { type: 'json' };
export const NFTContractArtifact = loadContractArtifact(NFTContractArtifactJson as NoirCompiledContract);


export type NFTTransfer = {
  from: AztecAddressLike
  to: AztecAddressLike
  token_id: FieldLike
}


export type MetadataUpdate = {
  token_id: FieldLike
  owner: AztecAddressLike
}


/**
 * Type-safe interface for contract NFT;
 */
export class NFTContract extends ContractBase {

  private constructor(
    address: AztecAddress,
    wallet: Wallet,
  ) {
    super(address, NFTContractArtifact, wallet);
  }



  /**
   * Creates a contract instance.
   * @param address - The deployed contract's address.
   * @param wallet - The wallet to use when interacting with the contract.
   * @returns A new Contract instance.
   */
  public static at(
    address: AztecAddress,
    wallet: Wallet,
  ): NFTContract {
    return Contract.at(address, NFTContract.artifact, wallet) as NFTContract;
  }


  /**
   * Creates a tx to deploy a new instance of this contract.
   */
  public static deploy(wallet: Wallet, admin: AztecAddressLike, name: string, symbol: string, erc20_token: AztecAddressLike, is_mint_public: boolean, mint_limit_per_wallet: (bigint | number), max_supply: (bigint | number), mint_price: (bigint | number), whitelist_mint_price: (bigint | number), public_start_unix: (bigint | number), whitelist_start_unix: (bigint | number), public_mint_time_secs: (bigint | number), whitelist_mint_time_secs: (bigint | number), upgrade_authority: AztecAddressLike) {
    return new DeployMethod<NFTContract>(PublicKeys.default(), wallet, NFTContractArtifact, (instance, wallet) => NFTContract.at(instance.address, wallet), Array.from(arguments).slice(1));
  }

  /**
   * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
   */
  public static deployWithPublicKeys(publicKeys: PublicKeys, wallet: Wallet, admin: AztecAddressLike, name: string, symbol: string, erc20_token: AztecAddressLike, is_mint_public: boolean, mint_limit_per_wallet: (bigint | number), max_supply: (bigint | number), mint_price: (bigint | number), whitelist_mint_price: (bigint | number), public_start_unix: (bigint | number), whitelist_start_unix: (bigint | number), public_mint_time_secs: (bigint | number), whitelist_mint_time_secs: (bigint | number), upgrade_authority: AztecAddressLike) {
    return new DeployMethod<NFTContract>(publicKeys, wallet, NFTContractArtifact, (instance, wallet) => NFTContract.at(instance.address, wallet), Array.from(arguments).slice(2));
  }

  /**
   * Creates a tx to deploy a new instance of this contract using the specified constructor method.
   */
  public static deployWithOpts<M extends keyof NFTContract['methods']>(
    opts: { publicKeys?: PublicKeys; method?: M; wallet: Wallet },
    ...args: Parameters<NFTContract['methods'][M]>
  ) {
    return new DeployMethod<NFTContract>(
      opts.publicKeys ?? PublicKeys.default(),
      opts.wallet,
      NFTContractArtifact,
      (instance, wallet) => NFTContract.at(instance.address, wallet),
      Array.from(arguments).slice(1),
      opts.method ?? 'constructor',
    );
  }



  /**
   * Returns this contract's artifact.
   */
  public static get artifact(): ContractArtifact {
    return NFTContractArtifact;
  }

  /**
   * Returns this contract's artifact with public bytecode.
   */
  public static get artifactForPublic(): ContractArtifact {
    return loadContractArtifactForPublic(NFTContractArtifactJson as NoirCompiledContract);
  }


  public static get storage(): ContractStorageLayout<'private_nfts' | 'symbol' | 'name' | 'admin' | 'minters' | 'nft_exists' | 'public_owners' | 'token_uris' | 'base_uri' | 'erc20_token' | 'fee_recipient' | 'owner_nft_count' | 'nft_mint_count' | 'total_nft_count' | 'is_mint_public' | 'mint_limit_per_wallet' | 'max_supply' | 'mint_price' | 'whitelist_mint_price' | 'whitelist_root' | 'public_start_unix' | 'whitelist_start_unix' | 'public_mint_time_secs' | 'whitelist_mint_time_secs' | 'upgrade_authority'> {
    return {
      private_nfts: {
        slot: new Fr(1n),
      },
      symbol: {
        slot: new Fr(2n),
      },
      name: {
        slot: new Fr(4n),
      },
      admin: {
        slot: new Fr(6n),
      },
      minters: {
        slot: new Fr(7n),
      },
      nft_exists: {
        slot: new Fr(8n),
      },
      public_owners: {
        slot: new Fr(9n),
      },
      token_uris: {
        slot: new Fr(10n),
      },
      base_uri: {
        slot: new Fr(11n),
      },
      erc20_token: {
        slot: new Fr(13n),
      },
      fee_recipient: {
        slot: new Fr(15n),
      },
      owner_nft_count: {
        slot: new Fr(16n),
      },
      nft_mint_count: {
        slot: new Fr(17n),
      },
      total_nft_count: {
        slot: new Fr(18n),
      },
      is_mint_public: {
        slot: new Fr(19n),
      },
      mint_limit_per_wallet: {
        slot: new Fr(20n),
      },
      max_supply: {
        slot: new Fr(21n),
      },
      mint_price: {
        slot: new Fr(22n),
      },
      whitelist_mint_price: {
        slot: new Fr(23n),
      },
      whitelist_root: {
        slot: new Fr(24n),
      },
      public_start_unix: {
        slot: new Fr(25n),
      },
      whitelist_start_unix: {
        slot: new Fr(26n),
      },
      public_mint_time_secs: {
        slot: new Fr(27n),
      },
      whitelist_mint_time_secs: {
        slot: new Fr(28n),
      },
      upgrade_authority: {
        slot: new Fr(29n),
      }
    } as ContractStorageLayout<'private_nfts' | 'symbol' | 'name' | 'admin' | 'minters' | 'nft_exists' | 'public_owners' | 'token_uris' | 'base_uri' | 'erc20_token' | 'fee_recipient' | 'owner_nft_count' | 'nft_mint_count' | 'total_nft_count' | 'is_mint_public' | 'mint_limit_per_wallet' | 'max_supply' | 'mint_price' | 'whitelist_mint_price' | 'whitelist_root' | 'public_start_unix' | 'whitelist_start_unix' | 'public_mint_time_secs' | 'whitelist_mint_time_secs' | 'upgrade_authority'>;
  }


  /** Type-safe wrappers for the public methods exposed by the contract. */
  public declare methods: {

    /** cancel_authwit(inner_hash: field) */
    cancel_authwit: ((inner_hash: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** constructor(admin: struct, name: string, symbol: string, erc20_token: struct, is_mint_public: boolean, mint_limit_per_wallet: integer, max_supply: integer, mint_price: integer, whitelist_mint_price: integer, public_start_unix: integer, whitelist_start_unix: integer, public_mint_time_secs: integer, whitelist_mint_time_secs: integer, upgrade_authority: struct) */
    constructor: ((admin: AztecAddressLike, name: string, symbol: string, erc20_token: AztecAddressLike, is_mint_public: boolean, mint_limit_per_wallet: (bigint | number), max_supply: (bigint | number), mint_price: (bigint | number), whitelist_mint_price: (bigint | number), public_start_unix: (bigint | number), whitelist_start_unix: (bigint | number), public_mint_time_secs: (bigint | number), whitelist_mint_time_secs: (bigint | number), upgrade_authority: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** finalize_transfer_to_private(token_id: field, partial_note: struct) */
    finalize_transfer_to_private: ((token_id: FieldLike, partial_note: { commitment: FieldLike }) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_admin() */
    get_admin: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_max_supply() */
    get_max_supply: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_mint_price() */
    get_mint_price: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_name() */
    get_name: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_nft_count(owner: struct) */
    get_nft_count: ((owner: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_note(owner: struct) */
    get_note: ((owner: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_private_nfts(owner: struct, page_index: integer) */
    get_private_nfts: ((owner: AztecAddressLike, page_index: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_symbol() */
    get_symbol: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_token_uri(token_id: field) */
    get_token_uri: ((token_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_total_nft_count() */
    get_total_nft_count: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_whitelist_root() */
    get_whitelist_root: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** is_mint_public() */
    is_mint_public: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** is_minter(minter: struct) */
    is_minter: ((minter: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** mint(to: struct, token_id: field, token_uri_parts: array, nonce: field) */
    mint: ((to: AztecAddressLike, token_id: FieldLike, token_uri_parts: string[], nonce: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** mint_private(to: struct, token_uri_parts: array, nonce: field, token_id: field) */
    mint_private: ((to: AztecAddressLike, token_uri_parts: string[], nonce: FieldLike, token_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** owner_of(token_id: field) */
    owner_of: ((token_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** process_message(message_ciphertext: struct, message_context: struct) */
    process_message: ((message_ciphertext: FieldLike[], message_context: { tx_hash: FieldLike, unique_note_hashes_in_tx: FieldLike[], first_nullifier_in_tx: FieldLike, recipient: AztecAddressLike }) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** public_dispatch(selector: field) */
    public_dispatch: ((selector: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_admin(new_admin: struct) */
    set_admin: ((new_admin: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_base_uri(base_uri_parts: array) */
    set_base_uri: ((base_uri_parts: string[]) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_fee_recipient(recipient: struct) */
    set_fee_recipient: ((recipient: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_mint_limit_per_wallet(new_mint_limit: integer) */
    set_mint_limit_per_wallet: ((new_mint_limit: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_mint_price(new_price: integer) */
    set_mint_price: ((new_price: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_mint_type(is_mint_public: boolean) */
    set_mint_type: ((is_mint_public: boolean) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_minter(minter: struct, approve: boolean) */
    set_minter: ((minter: AztecAddressLike, approve: boolean) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_public_start_time_and_duration(start_time: integer, duration_secs: integer) */
    set_public_start_time_and_duration: ((start_time: (bigint | number), duration_secs: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_whitelist_root(root: field) */
    set_whitelist_root: ((root: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_whitelist_start_time_and_duration(start_time: integer, duration_secs: integer) */
    set_whitelist_start_time_and_duration: ((start_time: (bigint | number), duration_secs: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** sync_private_state() */
    sync_private_state: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** transfer_private_to_private(from: struct, to: struct, token_id: field, _nonce: field) */
    transfer_private_to_private: ((from: AztecAddressLike, to: AztecAddressLike, token_id: FieldLike, _nonce: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** transfer_private_to_public(from: struct, to: struct, token_id: field, nonce: field) */
    transfer_private_to_public: ((from: AztecAddressLike, to: AztecAddressLike, token_id: FieldLike, nonce: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** transfer_public_to_private(to: struct, token_id: field) */
    transfer_public_to_private: ((to: AztecAddressLike, token_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** transfer_public_to_public(from: struct, to: struct, token_id: field, nonce: field) */
    transfer_public_to_public: ((from: AztecAddressLike, to: AztecAddressLike, token_id: FieldLike, nonce: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** upgrade_contract(new_contract_class_id: field) */
    upgrade_contract: ((new_contract_class_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** whitelist_mint(token_id: field, token_uri_parts: array, nonce: field, depth: integer, proof_indices: array, proof_siblings: array, secret: field) */
    whitelist_mint: ((token_id: FieldLike, token_uri_parts: string[], nonce: FieldLike, depth: (bigint | number), proof_indices: (bigint | number)[], proof_siblings: FieldLike[], secret: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;
  };


  public static get events(): { NFTTransfer: { abiType: AbiType, eventSelector: EventSelector, fieldNames: string[] }, MetadataUpdate: { abiType: AbiType, eventSelector: EventSelector, fieldNames: string[] } } {
    return {
      NFTTransfer: {
        abiType: {
          "kind": "struct",
          "fields": [
            {
              "name": "from",
              "type": {
                "kind": "struct",
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "kind": "struct",
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "path": "NFT::NFTTransfer"
        },
        eventSelector: EventSelector.fromString("0x54e38003"),
        fieldNames: ["from", "to", "token_id"],
      },
      MetadataUpdate: {
        abiType: {
          "kind": "struct",
          "fields": [
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "owner",
              "type": {
                "kind": "struct",
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "path": "NFT::MetadataUpdate"
        },
        eventSelector: EventSelector.fromString("0xe6df86de"),
        fieldNames: ["token_id", "owner"],
      }
    };
  }

}
